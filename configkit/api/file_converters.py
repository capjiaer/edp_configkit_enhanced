#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
File conversion API for configkit.

This module provides high-level API functions for converting between different file formats:
YAML files, Tcl files, and mixed file conversions.

本模块提供不同文件格式间转换的高级API功能：YAML文件、Tcl文件和混合文件转换。
"""

import os
import yaml
from tkinter import Tcl
from typing import Dict

from ..core.dict_operations import merge_dict, yamlfiles2dict
from ..core.tcl_interpreter import (
    dict2tclinterp, tclinterp2dict, tclfiles2tclinterp, 
    _write_tcl_vars_to_file
)


def files2dict(*input_files: str, mode: str = "auto", skip_errors: bool = False, variable_interp=None) -> Dict:
    """
    Convert a mixed list of YAML and Tcl files to a single Python dictionary.
    Files are processed in order and merged into a single dictionary.

    Args:
        *input_files: One or more paths to YAML or Tcl files
        mode: Conversion mode for Tcl values ("auto", "str", or "list")
        skip_errors: Whether to skip files that cause errors (True) or raise exceptions (False)
        variable_interp: Optional Tcl interpreter for cross-file variable resolution.
                        If provided, variables like $var in YAML values will be resolved 
                        using variables from both Tcl and YAML files.
                        If None, no variable resolution is performed (default behavior).

    Returns:
        Dictionary containing merged content from all input files

    Raises:
        FileNotFoundError: If any of the input files doesn't exist and skip_errors is False
        ValueError: If no input files are provided
        Exception: Various exceptions from file processing if skip_errors is False
        
    Example:
        # Basic usage (no variable resolution)
        config = files2dict("base.tcl", "app.yaml")
        
        # With cross-file variable resolution
        from configkit.core.tcl_interpreter import create_tcl_interp
        interp = create_tcl_interp()
        config = files2dict("base.tcl", "app.yaml", variable_interp=interp)
    """
    if not input_files:
        raise ValueError("At least one input file must be provided")

    # Initialize an empty result dictionary
    result_dict = {}

    # Process each input file and merge into the result dictionary
    for input_file in input_files:
        try:
            if not os.path.exists(input_file):
                if skip_errors:
                    continue
                else:
                    raise FileNotFoundError(f"Input file not found: {input_file}")

            # Determine file type based on extension
            file_ext = os.path.splitext(input_file)[1].lower()

            # Process based on file type
            if file_ext in ('.yaml', '.yml'):
                # Handle YAML file
                with open(input_file, 'r', encoding='utf-8') as yf:
                    yaml_dict = yaml.safe_load(yf)

                if yaml_dict:  # Skip empty YAML files
                    result_dict = merge_dict(result_dict, yaml_dict)

            elif file_ext in ('.tcl', '.tk'):
                # Handle Tcl file
                # Load the Tcl file into an interpreter
                interp = tclfiles2tclinterp(input_file)

                # Convert to dictionary
                tcl_dict = tclinterp2dict(interp, mode=mode)

                # Merge with result
                result_dict = merge_dict(result_dict, tcl_dict)
        except Exception as e:
            if not skip_errors:
                raise

    # If variable resolution is requested, perform cross-file variable resolution
    if variable_interp is not None:
        dict2tclinterp(result_dict, variable_interp)
        result_dict = tclinterp2dict(variable_interp)

    return result_dict


def files2tclfile(*input_files: str, output_file: str, add_source_comments: bool = True) -> None:
    """
    Convert a mixed list of YAML and Tcl files to a single Tcl file.
    Files are processed in order, with each file's content written sequentially to the output file.

    Args:
        *input_files: One or more paths to YAML or Tcl files
        output_file: Path to the output Tcl file
        add_source_comments: Whether to add comments indicating the source file for each section

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the input files doesn't exist
        ValueError: If no input files are provided
    """
    if not input_files:
        raise ValueError("At least one input file must be provided")

    # Open the output file for writing
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n\n")

        # Process each input file sequentially
        for input_file in input_files:
            if not os.path.exists(input_file):
                raise FileNotFoundError(f"Input file not found: {input_file}")

            # Get the absolute path of the file
            abs_path = os.path.abspath(input_file)

            # Determine file type based on extension
            file_ext = os.path.splitext(input_file)[1].lower()

            # Add a comment indicating the source file
            if add_source_comments:
                f.write(f"\n# From {abs_path}\n")

            # Process based on file type
            if file_ext in ('.yaml', '.yml'):
                # Handle YAML file
                with open(input_file, 'r', encoding='utf-8') as yf:
                    yaml_dict = yaml.safe_load(yf)

                if not yaml_dict:  # Handle empty YAML files
                    f.write("# (Empty file - no variables defined)\n")
                    continue

                # Convert dictionary to Tcl interpreter
                interp = dict2tclinterp(yaml_dict)

                # Write all variables from this file
                _write_tcl_vars_to_file(interp, f)

            elif file_ext in ('.tcl', '.tk'):
                # Handle Tcl file
                # Create a new interpreter
                interp = Tcl()

                try:
                    # Source the Tcl file
                    interp.eval(f"source {{{input_file}}}")

                    # Write all variables from this interpreter
                    _write_tcl_vars_to_file(interp, f)

                except Exception as e:
                    f.write(f"# Error loading Tcl file: {str(e)}\n")
            else:
                # Unknown file type
                f.write(f"# Skipping file with unknown extension: {file_ext}\n")


def files2yamlfile(*input_files: str, output_file: str, mode: str = "auto") -> None:
    """
    Convert a mixed list of YAML and Tcl files to a single YAML file.
    Files are processed in order and merged into a single dictionary.

    Args:
        *input_files: One or more paths to YAML or Tcl files
        output_file: Path to the output YAML file
        mode: Conversion mode for Tcl values ("auto", "str", or "list")

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the input files doesn't exist
        ValueError: If no input files are provided
    """
    # Convert files to dictionary
    result_dict = files2dict(*input_files, mode=mode)

    # Write the result dictionary to the output YAML file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n")
        yaml.dump(result_dict, f, default_flow_style=False, sort_keys=False)


def tclfiles2yamlfile(*tcl_files: str, output_file: str, mode: str = "auto") -> None:
    """
    Convert one or more Tcl files to a YAML file.

    Args:
        *tcl_files: One or more paths to Tcl files
        output_file: Path to the output YAML file
        mode: Conversion mode for space-separated values without type information:
              - "auto": Use type information if available, otherwise make best guess
              - "str": Always treat space-separated values as strings
              - "list": Always convert space-separated values to lists

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the Tcl files doesn't exist
    """
    # Load Tcl files into an interpreter
    interp = tclfiles2tclinterp(*tcl_files)

    # Convert interpreter to dictionary
    data = tclinterp2dict(interp, mode=mode)

    # Write dictionary to YAML file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n")
        yaml.dump(data, f, default_flow_style=False, sort_keys=False)


def yamlfiles2tclfile(*yaml_files: str, output_file: str, add_source_comments: bool = True) -> None:
    """
    Convert one or more YAML files to a Tcl file.
    Each YAML file's content is written sequentially to the Tcl file with source comments.

    Args:
        *yaml_files: One or more paths to YAML files
        output_file: Path to the output Tcl file
        add_source_comments: Whether to add comments indicating the source file for each section

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the YAML files doesn't exist
        yaml.YAMLError: If there's an error parsing any YAML file
    """
    if not yaml_files:
        raise ValueError("At least one YAML file must be provided")

    # Open the output file for writing
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n\n")

        # Process each YAML file sequentially
        for yaml_file in yaml_files:
            if not os.path.exists(yaml_file):
                raise FileNotFoundError(f"YAML file not found: {yaml_file}")

            # Get the absolute path of the file
            abs_path = os.path.abspath(yaml_file)

            # Load the YAML file
            with open(yaml_file, 'r', encoding='utf-8') as yf:
                yaml_dict = yaml.safe_load(yf)

            # Add a comment indicating the source file
            if add_source_comments:
                f.write(f"\n# From {abs_path}\n")

            if not yaml_dict:  # Handle empty YAML files
                f.write("# (Empty file - no variables defined)\n")
                continue

            # Convert dictionary to Tcl interpreter
            interp = dict2tclinterp(yaml_dict)

            # Write all variables from this file
            _write_tcl_vars_to_file(interp, f) 